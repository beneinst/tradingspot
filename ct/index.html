<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatterText</title>
	<link rel="icon" href="favicon.ico" />
  <style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

   body {
    font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    /* Immagine di sfondo con overlay scuro per mantenere il contrasto */
    background: linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), 
                url('black.jpg') no-repeat center center;
    background-size: cover;
    background-attachment: fixed; /* L'immagine non si muove allo scroll */
    color: #e0e0e0;
    min-height: 100vh;
    padding: 20px;
    line-height: 1.6;
}

    .container {
        max-width: 1200px;
        margin: 0 auto;
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border-radius: 24px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        overflow: hidden;
    }

    .header {
    /* Sostituisci 'sfoh.jpg' con l'URL della tua immagine */
    background: linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.05)), 
                url('sfoh.jpg') no-repeat center center;
    background-size: cover;
    padding: 40px 30px; /* Un po' pi√π di respiro verticale */
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    text-align: left;
    position: relative;
}

.header h1 {
    font-family: 'Times New Roman', Georgia, serif;
    font-size: 2.0em;
    color: #ffffff;
    /* Ombra profonda per staccare il testo dallo sfondo */
    text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.8); 
    margin: 0;
}

    .content {
        padding: 30px;
    }

    /* --- TEXTAREA PI√ô ALTA (400px) --- */
    textarea {
        width: 100%;
        min-height: 400px; /* Aumentato come richiesto */
        background: rgba(255, 255, 255, 0.07);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        color: #fff;
        padding: 20px;
        font-family: 'Courier New', monospace;
        font-size: 16px;
        transition: all 0.3s ease;
        resize: vertical;
    }

    textarea:focus {
        outline: none;
        border-color: #81ecec;
        background: rgba(255, 255, 255, 0.12);
        box-shadow: 0 0 15px rgba(129, 236, 236, 0.2);
    }

    /* --- LAYOUT BOX STATISTICHE ORIZZONTALE --- */
    .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* Forza l'allineamento orizzontale */
        gap: 20px;
        margin: 30px 0;
    }

    .stat-card {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 25px;
        border-radius: 15px;
        text-align: center;
        transition: transform 0.3s, background 0.3s;
    }

    .stat-card:hover {
        transform: translateY(-5px);
        background: rgba(255, 255, 255, 0.06);
        border-color: rgba(129, 236, 236, 0.3);
    }

    .stat-card .number {
        color: #81ecec;
        font-size: 2.2em;
        font-weight: bold;
        display: block;
    }

    .stat-card .label {
        color: #bdc3c7;
        margin-top: 8px;
        text-transform: uppercase;
        font-size: 0.85em;
        letter-spacing: 1px;
    }

    /* Pulsanti */
    .controls {
        display: flex;
        gap: 15px;
        margin-bottom: 25px;
    }

    .btn {
        flex: 1;
        background: rgba(74, 144, 226, 0.2);
        color: #fff;
        border: 1px solid rgba(74, 144, 226, 0.4);
        padding: 15px;
        border-radius: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
    }

    .btn:hover {
        background: rgba(74, 144, 226, 0.4);
        box-shadow: 0 0 20px rgba(74, 144, 226, 0.2);
    }

    /* Responsive */
    @media (max-width: 768px) {
        .stats {
            grid-template-columns: 1fr 1fr; /* Due colonne su mobile */
        }
        .controls {
            flex-direction: column;
        }
    }
	
	/* Contenitore principale dei controlli per distanziarlo dalle stats */
    .controls-container {
        display: flex;
        flex-direction: column;
        gap: 20px;
        margin: 30px 0;
        padding: 20px;
        background: rgba(255, 255, 255, 0.02);
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.05);
    }

    /* Layout a riga per i gruppi di input */
    .controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        align-items: flex-end;
    }

    /* Stile per il singolo gruppo Label + Input */
    .control-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .control-group label {
        font-size: 0.85rem;
        font-weight: 600;
        color: #81ecec; /* Colore neon per richiamare le stats */
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-left: 5px;
    }

    /* Input stile Glass */
    .control-group input {
        background: rgba(255, 255, 255, 0.07);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        padding: 12px;
        color: #ffffff;
        font-family: 'Segoe UI', sans-serif;
        font-size: 0.95rem;
        transition: all 0.3s ease;
        width: 100%;
    }

    /* Effetto Focus sugli input */
    .control-group input:focus {
        outline: none;
        background: rgba(255, 255, 255, 0.12);
        border-color: #81ecec;
        box-shadow: 0 0 10px rgba(129, 236, 236, 0.2);
    }

    /* Rimuove le freccette standard dagli input number per un look pi√π pulito */
    input[type=number]::-webkit-inner-spin-button, 
    input[type=number]::-webkit-outer-spin-button { 
        -webkit-appearance: none; 
        margin: 0; 
    }
    input[type=number] {
        -moz-appearance: textfield;
    }

    /* Placeholder stile sottile */
    .control-group input::placeholder {
        color: rgba(255, 255, 255, 0.3);
    }

    /* Responsive: su schermi piccoli impila i controlli */
    @media (max-width: 768px) {
        .controls {
            grid-template-columns: 1fr 1fr;
        }
    }
	
	Per completare lo stile Dark Glass, il chunk-header deve fungere da "barra del titolo" elegante per ogni blocco di testo generato. Utilizzeremo una sfocatura leggermente diversa e un layout flessibile per tenere in ordine il titolo, le informazioni tecniche (caratteri/parole) e i pulsanti di azione.

Ecco il codice CSS da aggiungere:

CSS
<style>
    /* Contenitore dell'intestazione del chunk */
    .chunk-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 20px;
        background: rgba(255, 255, 255, 0.08); /* Leggermente pi√π chiaro del corpo */
        backdrop-filter: blur(5px);
        border-radius: 12px 12px 0 0; /* Arrotondato solo sopra */
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        margin-bottom: 0; /* Si attacca perfettamente al box sotto */
    }

    /* Titolo del Chunk (es. "Chunk #1") */
    .chunk-title {
        font-weight: 700;
        color: #81ecec; /* Ciano neon coerente con le stats */
        text-transform: uppercase;
        font-size: 0.9rem;
        letter-spacing: 1.5px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    /* Area informazioni (Conteggio parole/caratteri) */
    .chunk-info {
        display: flex;
        gap: 20px;
        font-size: 0.85rem;
        color: #bdc3c7;
        font-weight: 500;
    }

    /* Badge per i dati numerici nell'header */
    .chunk-info span {
        background: rgba(0, 0, 0, 0.3);
        padding: 2px 10px;
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.05);
        color: #fff;
    }

    /* Container per i pulsanti (Copia, Elimina, ecc.) */
    .chunk-actions {
        display: flex;
        gap: 10px;
    }

    /* Pulsanti piccoli stile Glass */
    .btn-small {
        padding: 6px 12px;
        font-size: 0.75rem;
        font-weight: 700;
        text-transform: uppercase;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.05);
        color: #fff;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .btn-small:hover {
        background: rgba(129, 236, 236, 0.2); /* Bagliore ciano al passaggio */
        border-color: #81ecec;
        transform: translateY(-1px);
    }

    /* Variante pulsante elimina/pericolo nell'header */
    .btn-danger-small {
        border-color: rgba(232, 67, 87, 0.4);
    }

    .btn-danger-small:hover {
        background: rgba(232, 67, 87, 0.3);
        border-color: #e84357;
    }
</style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üíΩ ChatterText</h1>
            <p>Analizza e prepara il testo per Chatterbox TTS</p>
        </div>

        <div class="content">
            <!-- Input Section -->
            <div class="section">
                <h2>üìù Inserisci il Testo</h2>
                <textarea id="inputText" placeholder="Incolla qui il tuo testo (fino a 10000 caratteri)..."></textarea>
                
              <div class="controls-container">
    <div class="controls">
        <div class="control-group">
            <label>Parole per Chunk (min)</label>
            <input type="number" id="minWords" value="20" min="15" max="40">
        </div>
        <div class="control-group">
            <label>Parole per Chunk (max)</label>
            <input type="number" id="maxWords" value="40" min="35" max="65">
        </div>
        <div class="control-group">
            <label>Caratteri massimi</label>
            <input type="number" id="maxChars" value="240" min="200" max="380">
        </div>
    </div>

    <div class="controls" style="margin-top: 20px;">
        <div class="control-group" style="flex: 2;">
            <label>üéôÔ∏è File Voce (nella cartella 2.Voci/)</label>
            <input type="text" id="voiceFile" value="3l14n.wav" placeholder="nome_voce.wav">
        </div>
        <div class="control-group">
            <label>Exaggeration</label>
            <input type="number" id="exaggeration" value="0.62" min="0.4" max="0.8" step="0.01">
        </div>
        <div class="control-group">
            <label>CFG Weight</label>
            <input type="number" id="cfgWeight" value="0.70" min="0.4" max="0.8" step="0.01">
        </div>
        <div class="control-group">
            <label>Temperature</label>
            <input type="number" id="temperature" value="0.58" min="0.45" max="0.75" step="0.01">
        </div>
    </div>
</div>
			

                <div class="controls" style="margin-top: 20px;">
                    <button class="btn" onclick="processText()">üîç Analizza e Processa</button>
                    <button class="btn btn-secondary" onclick="clearAll()">üóëÔ∏è Cancella Tutto</button>
                </div>
            </div>

            <!-- Stats Section -->
            <div id="statsSection" class="section hidden">
                <h2>üìä Statistiche</h2>
                <div class="stats">
                    <div class="stat-card">
                        <div class="number" id="totalWords">0</div>
                        <div class="label">Parole Totali</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="totalChars">0</div>
                        <div class="label">Caratteri</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="totalChunks">0</div>
                        <div class="label">Chunk Generati</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="errorCount">0</div>
                        <div class="label">Problemi Trovati</div>
                    </div>
					<div class="stat-card"><div id="tagInfo" style="margin-top: 8px; font-weight: bold; grid-column: 1 / -1;"></div></div>
                </div>
            </div>

            <!-- Errors Section -->
            <div id="errorsSection" class="hidden"></div>

            <!-- Chunks Section -->
            <div id="chunksSection" class="section hidden">
                <h2><BR>üì¶ Chunk Generati</h2><p><br></p>
                <div class="controls">
                    
                    <button class="btn btn-edit" onclick="exportPythonScript()">üöÄ Genera Script Chatterbox-Auto</button>
                    
                </div>
                <div id="chunksContainer" class="chunks-container"></div>
            </div>
        </div>
    </div>
<div style="padding-top: 1px; padding-bottom: 1px;">
      
      		   <p style="margin: 0; color: #c3c3c3; padding-top:25px; padding-bottom:35px; text-align: center; height: 15px; line-height: 12px;">
        üíΩ 2026 ¬© ChatterText by Gerardo D'Orrico
      </p>
    </div>
    <script>
        function normalizeText(text) {
    text = text.replace(/l'Om\b/g, "l'om");
    text = text.replace(/nell'(\w)/g, (m, p1) => `nell'${p1.toLowerCase()}`);
    text = text.replace(/dell'(\w)/g, (m, p1) => `dell'${p1.toLowerCase()}`);
    text = text.replace(/[`¬¥]/g, "'");
    text = text.replace(/[^\w\s.,;:!?√Ä-√π√Ä-√ú'"\-]/g, '');
    text = text.replace(/\s+/g, ' ');
    text = text.replace(/\n\s*\n+/g, '\n\n');
    text = text.replace(/(?<!\n)\n(?!\n)/g, ' ');
    text = text.replace(/([.!?])\1+/g, '$1');

    // ‚úÖ PAUSE TRA FRASI E VIRGOLE
    text = text.replace(/\. /g, '.  ');       // pausa dopo punto
    text = text.replace(/\? /g, '?  ');       // pausa dopo domanda
    text = text.replace(/! /g, '!  ');        // pausa dopo esclamazione
    text = text.replace(/, /g, ',  ');        // micro-pausa dopo virgola
    text = text.replace(/; /g, ';  ');        // pausa dopo punto e virgola
	// Spezza frasi lunghissime senza punteggiatura (oltre 15 parole)
	text = text.replace(/(\b\w+\b(?:\s+\b\w+\b){14})\s+/g, '$1, ');

    return text.trim();
}

function analyzeText(text) {
    const errors = [];
    
    if (text.length > 10000) {
        errors.push({
            type: 'warning',
            message: `Il testo √® troppo lungo (${text.length} caratteri). Massimo 10000.`
        });
    }
    
    const capsAfterApos = text.match(/[''`¬¥]\w*[A-Z]\w*/g);
    if (capsAfterApos) {
        errors.push({
            type: 'warning',
            message: `Trovate ${capsAfterApos.length} maiuscole dopo apostrofo: ${capsAfterApos.slice(0, 3).join(', ')}...`
        });
    }
    
    const words = text.toLowerCase().match(/\b\w+\b/g) || [];
    const wordCount = {};
    words.forEach(w => wordCount[w] = (wordCount[w] || 0) + 1);
    
    const repeated = Object.entries(wordCount)
        .filter(([word, count]) => count > 3 && word.length > 3)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
    
    if (repeated.length > 0) {
        errors.push({
            type: 'info',
            message: `Parole molto ripetute: ${repeated.map(([w, c]) => `"${w}" (${c}x)`).join(', ')}`
        });
    }
    
    const specialChars = text.match(/[^\w\s.,;:!?√Ä-√π√Ä-√ú'"\-]/g);
    if (specialChars) {
        const unique = [...new Set(specialChars)];
        errors.push({
            type: 'warning',
            message: `Caratteri speciali trovati: ${unique.slice(0, 10).join(' ')}`
        });
    }
    
    return errors;
}

function chunkText(text, minWords, maxWords, maxChars) {

    // 1Ô∏è‚É£ SE CI SONO TAG, USALI
    const tagPattern = /\[inizio\]([\s\S]*?)\[fine\]/gi;
    const tagMatches = Array.from(text.matchAll(tagPattern));

    if (tagMatches.length > 0) {
        return tagMatches.map(m => m[1].trim()).filter(c => c.length > 0);
    }

    // 2Ô∏è‚É£ SE NON CI SONO TAG ‚Üí GENERALI AUTOMATICAMENTE

    // Dividi per paragrafi (riga vuota)
    let paragrafi = text.split(/\n\s*\n/).map(p => p.trim()).filter(p => p.length > 0);

    // Se i paragrafi sono troppo lunghi ‚Üí spezza in frasi
    let chunks = [];

    for (let p of paragrafi) {
        if (p.length <= maxChars && p.split(/\s+/).length <= maxWords) {
            chunks.push(p);
            continue;
        }

        // Spezza in frasi
        const frasi = p.match(/[^.!?]+[.!?]+/g) || [p];

        let buffer = "";

        for (let frase of frasi) {
            const test = buffer ? buffer + " " + frase : frase;

            if (test.length > maxChars || test.split(/\s+/).length > maxWords) {
                if (buffer.trim().length > 0) chunks.push(buffer.trim());
                buffer = frase;
            } else {
                buffer = test;
            }
        }

        if (buffer.trim().length > 0) chunks.push(buffer.trim());
    }

    return chunks;
}



function getChunkStatus(words, chars) {
    if (words > 60 || chars > 350) return { badge: 'danger', text: 'Troppo lungo' };
    if (words < 20 || chars < 100) return { badge: 'warning', text: 'Troppo corto' };
    return { badge: 'success', text: 'Ottimale' };
}

function processText() {
    const text = document.getElementById('inputText').value;
    
    if (!text.trim()) {
        alert('Inserisci del testo prima di processare!');
        return;
    }

    // ‚úÖ Estrai i tag PRIMA della normalizzazione
    const hasTagMode = /\[inizio\]/i.test(text);
    
    let normalized;
    if (hasTagMode) {
        // Normalizza ogni chunk tra i tag separatamente, preservando i tag
        normalized = text.replace(/\[inizio\]([\s\S]*?)\[fine\]/gi, (match, content) => {
            return '[inizio]' + normalizeText(content) + '[fine]';
        });
    } else {
        normalized = normalizeText(text);
    }
    const errors = analyzeText(normalized);
    
    const words = normalized.split(/\s+/).filter(w => w.length > 0);
    document.getElementById('totalWords').textContent = words.length;
    document.getElementById('totalChars').textContent = normalized.length;
    document.getElementById('errorCount').textContent = errors.length;
    
    document.getElementById('statsSection').classList.remove('hidden');
    
    const errorsSection = document.getElementById('errorsSection');
    if (errors.length > 0) {
        errorsSection.className = 'errors';
        errorsSection.innerHTML = '<h3>‚ö†Ô∏è Problemi Trovati</h3>' +
            errors.map(e => `<div class="error-item">${e.message}</div>`).join('');
        errorsSection.classList.remove('hidden');
    } else {
        errorsSection.className = 'success';
        errorsSection.innerHTML = '<h3>‚úÖ Nessun problema trovato!</h3>';
        errorsSection.classList.remove('hidden');
    }
    
    const minWords = parseInt(document.getElementById('minWords').value);
    const maxWords = parseInt(document.getElementById('maxWords').value);
    const maxChars = parseInt(document.getElementById('maxChars').value);
    
    const chunks = chunkText(normalized, minWords, maxWords, maxChars);
    document.getElementById('totalChunks').textContent = chunks.length;
    
    // ‚úÖ CONTATORE TAG [inizio]/[fine]
const tagCount = (normalized.match(/\[inizio\]/gi) || []).length;
const tagInfo = document.getElementById('tagInfo');
if (tagInfo) {
    if (tagCount > 0) {
        tagInfo.textContent = `üè∑Ô∏è Tag trovati: ${tagCount} blocchi [inizio]/[fine]`;
        tagInfo.style.color = '#28a745';
    } else {
        tagInfo.textContent = '‚öôÔ∏è Modalit√† automatica (nessun tag trovato)';
        tagInfo.style.color = '#ffc107';
    }
}
	
	const container = document.getElementById('chunksContainer');
    container.innerHTML = chunks.map((chunk, i) => {
        const words = chunk.split(/\s+/).length;
        const chars = chunk.length;
        const status = getChunkStatus(words, chars);
        
        return `
    <div class="chunk">
        <div class="chunk-header">
            <div class="chunk-title">Chunk ${i + 1}</div>
            <div class="chunk-info">
                <span id="chunk-words-${i}"><strong>${words}</strong> parole</span>
                <span id="chunk-chars-${i}"><strong>${chars}</strong> caratteri</span>
                <span id="chunk-badge-${i}" class="badge badge-${status.badge}">${status.text}</span>
            </div>
        </div>
        <textarea class="chunk-editor" id="chunk-${i}" oninput="updateChunkStats(${i})">${chunk}</textarea>
        <div class="chunk-actions">
            <button class="btn btn-small" onclick="copyChunk(${i})">üìã Copia</button>
            <button class="btn btn-small" onclick="saveChunk(${i})">üíæ Salva</button>
            <button class="btn btn-small" onclick="splitChunk(${i})" style="background: #ffc107;">‚úÇÔ∏è Dividi</button>
            ${i < chunks.length - 1 ? `<button class="btn btn-small" onclick="mergeChunk(${i})" style="background: #17a2b8;">üîó Unisci</button>` : ''}
        </div>
    </div>
`;
    }).join('');
    
    document.getElementById('chunksSection').classList.remove('hidden');
    window.processedChunks = chunks;
}

function updateChunkStats(index) {
    const textarea = document.getElementById(`chunk-${index}`);
    const text = textarea.value;
    const words = text.split(/\s+/).filter(w => w.length > 0).length;
    const chars = text.length;
    const status = getChunkStatus(words, chars);
    
    // Aggiorna le statistiche visualizzate
    document.getElementById(`chunk-words-${index}`).innerHTML = `<strong>${words}</strong> parole`;
    document.getElementById(`chunk-chars-${index}`).innerHTML = `<strong>${chars}</strong> caratteri`;
    
    const badgeEl = document.getElementById(`chunk-badge-${index}`);
    badgeEl.className = `badge badge-${status.badge}`;
    badgeEl.textContent = status.text;
    
    // Aggiorna l'array globale
    window.processedChunks[index] = text;
    
    // Ricalcola totali
    updateTotalStats();
}

function updateTotalStats() {
    const chunks = window.processedChunks;
    const totalWords = chunks.reduce((sum, chunk) => {
        return sum + chunk.split(/\s+/).filter(w => w.length > 0).length;
    }, 0);
    const totalChars = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
    
    document.getElementById('totalWords').textContent = totalWords;
    document.getElementById('totalChars').textContent = totalChars;
    document.getElementById('totalChunks').textContent = chunks.length;
}

function splitChunk(index) {
    const text = document.getElementById(`chunk-${index}`).value;
    
    // Chiedi all'utente dove vuole dividere
    const position = prompt(`Il chunk ha ${text.length} caratteri.\n\nInserisci la posizione dove dividere (0-${text.length}):\n\nOPPURE lascia vuoto per dividere a met√†.`);
    
    let splitPos;
    if (position === null) return; // Annullato
    
    if (position === '' || position === null) {
        // Trova il punto migliore a met√† (fine frase)
        const middle = Math.floor(text.length / 2);
        const searchWindow = text.substring(Math.max(0, middle - 100), Math.min(text.length, middle + 100));
        const sentenceEnd = searchWindow.match(/[.!?;:]\s/);
        
        if (sentenceEnd) {
            splitPos = middle - 100 + sentenceEnd.index + 2;
        } else {
            splitPos = middle;
        }
    } else {
        splitPos = parseInt(position);
        if (isNaN(splitPos) || splitPos < 1 || splitPos >= text.length) {
            alert('Posizione non valida!');
            return;
        }
    }
    
    // Dividi il testo
    const part1 = text.substring(0, splitPos).trim();
    const part2 = text.substring(splitPos).trim();
    
    // Aggiorna l'array
    window.processedChunks.splice(index, 1, part1, part2);
    
    // Ricarica la visualizzazione
    reloadChunks();
}

function mergeChunk(index) {
    if (index >= window.processedChunks.length - 1) {
        alert('Non ci sono chunk successivi da unire!');
        return;
    }
    
    const current = document.getElementById(`chunk-${index}`).value;
    const next = document.getElementById(`chunk-${index + 1}`).value;
    
    // Unisci con uno spazio
    const merged = current + ' ' + next;
    
    // Aggiorna l'array
    window.processedChunks.splice(index, 2, merged);
    
    // Ricarica la visualizzazione
    reloadChunks();
}

function reloadChunks() {
    const chunks = window.processedChunks;
    const container = document.getElementById('chunksContainer');
    
    container.innerHTML = chunks.map((chunk, i) => {
        const words = chunk.split(/\s+/).filter(w => w.length > 0).length;
        const chars = chunk.length;
        const status = getChunkStatus(words, chars);
        
        return `
            <div class="chunk">
                <div class="chunk-header">
                    <div class="chunk-title">Chunk ${i + 1}</div>
                    <div class="chunk-info">
                        <span id="chunk-words-${i}"><strong>${words}</strong> parole</span>
                        <span id="chunk-chars-${i}"><strong>${chars}</strong> caratteri</span>
                        <span id="chunk-badge-${i}" class="badge badge-${status.badge}">${status.text}</span>
                    </div>
                </div>
                <textarea class="chunk-editor" id="chunk-${i}" oninput="updateChunkStats(${i})">${chunk}</textarea>
                <div class="chunk-actions">
                    <button class="btn btn-small" onclick="copyChunk(${i})">üìã Copia</button>
                    <button class="btn btn-small" onclick="saveChunk(${i})">üíæ Salva</button>
                    <button class="btn btn-small" onclick="splitChunk(${i})" style="background: #ffc107;">‚úÇÔ∏è Dividi</button>
                    ${i < chunks.length - 1 ? `<button class="btn btn-small" onclick="mergeChunk(${i})" style="background: #17a2b8;">üîó Unisci</button>` : ''}
                </div>
            </div>
        `;
    }).join('');
    
    updateTotalStats();
}

function copyChunk(index) {
    const chunk = window.processedChunks[index];
    navigator.clipboard.writeText(chunk).then(() => {
        alert(`Chunk ${index + 1} copiato!`);
    });
}

function copyAllChunks() {
    const all = window.processedChunks.join('\n\n---\n\n');
    navigator.clipboard.writeText(all).then(() => {
        alert('Tutti i chunk copiati!');
    });
}

function saveChunk(index) {
    const chunk = window.processedChunks[index];
    const blob = new Blob([chunk], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `chunk_${index + 1}.txt`;
    a.click();
}

function downloadChunks() {
    const content = window.processedChunks.map((chunk, i) => 
        `=== CHUNK ${i + 1} ===\n${chunk}\n`
    ).join('\n\n');
    
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'chatterbox_chunks.txt';
    a.click();
}

function exportPythonScript() {
    const chunks = window.processedChunks;
	
	// Leggi i parametri dalla UI
    const voiceFile = document.getElementById('voiceFile').value.trim() || '3l14n.wav';
    const exaggeration = parseFloat(document.getElementById('exaggeration').value) || 0.62;
    const cfgWeight = parseFloat(document.getElementById('cfgWeight').value) || 0.70;
    const temperature = parseFloat(document.getElementById('temperature').value) || 0.58;

    // ‚úÖ FIX: costruiamo il testo Python per le liste con apostrofi
    // usando stringhe con virgolette doppie per evitare conflitti con gli apostrofi italiani
    const sceneStartersList = [
        "poi", "quando", "all'improvviso", "improvvisamente",
        "in quel momento", "mentre", "subito dopo", "intanto"
    ];
    const dialogVerbsList = [
        "disse", "penso", "grido", "urlo", "sussurro",
        "domando", "rispose", "chiese", "mormoro",
        "esclamo", "borbotto", "annuncio", "replico"
    ];
    const emotionalWordsList = [
        "paura", "orrore", "ansia", "terrore", "pianto",
        "felice", "gioia", "triste", "disperato",
        "sconvolto", "agitato", "sorpreso"
    ];

    // Serializza come Python list con virgolette doppie
    const pyList = arr => "[\n        " + arr.map(s => `"${s}"`).join(", ") + "\n    ]";

    const script = [
        "# Script generato automaticamente da Chatterbox Text Processor V2",
        "# Versione Ottimizzata - CPU Safe",
        "import os",
        "import torch",
        "import torchaudio as ta",
        "from chatterbox.mtl_tts import ChatterboxMultilingualTTS",
        "import pathlib",
        "import datetime",
        "",
        "# === PATCH map_location PRIMA di tutto ===",
        "_orig_torch_load = torch.load",
        "def _cpu_safe_load(*args, **kwargs):",
        "    kwargs.setdefault('map_location', torch.device('cpu'))",
        "    return _orig_torch_load(*args, **kwargs)",
        "torch.load = _cpu_safe_load",
        "",
        "# === CARICAMENTO MODELLO ===",
        "print('Caricamento modello Chatterbox...')",
        "model = ChatterboxMultilingualTTS.from_pretrained(device='cpu')",
        "print('Modello caricato!')",
        "",
        "# === CHUNK ===",
        "chunks = " + JSON.stringify(chunks, null, 4),
        "",
        "print(f'\\n Chunk da processare: {len(chunks)}')",
        "print(f' Lunghezze (parole): {[len(c.split()) for c in chunks]}')",
        "print(f' Lunghezze (caratteri): {[len(c) for c in chunks]}')",
        "",
        "for i, chunk in enumerate(chunks):",
        "    if len(chunk) > 400:",
        "        print(f' Chunk {i+1} e lungo {len(chunk)} caratteri (limite consigliato: 400)')",
        "",
        "# === AUDIO PROMPT ===",
        `AUDIO_PROMPT = "2.Voci/${voiceFile}"`,
        "",
        "if not os.path.exists(AUDIO_PROMPT):",
        "    print(f' File audio prompt non trovato: {AUDIO_PROMPT}')",
        "    print('   Modifica la variabile AUDIO_PROMPT con il percorso corretto')",
        "    exit(1)",
        "",
        "# === FUNZIONI DI PROSODIA E PAUSE INTERNE ===",
        "",
        "def inject_internal_pauses(text):",
        "    text = text.replace(\", \", \",  \")",
        "    text = text.replace(\"; \", \";   \")",
        "    text = text.replace(\": \", \":   \")",
        "    text = text.replace(\" - \", \" --  \")",
        "    text = text.replace(\") \", \")   \")",
        "    return text",
        "",
        "def prosody_params(text):",
        "    lower = text.lower()",
        "    params = {",
       `        'exaggeration': ${exaggeration},`,
        `        'cfg_weight': ${cfgWeight},`,
        `        'temperature': ${temperature},`,
        "        'top_p': 0.93,",
        "        'min_p': 0.035",
        "    }",
        "    if text.strip().startswith(('\"', \"'\")):  ",
        "        params['exaggeration'] = 0.70",
        "        params['temperature'] = 0.62",
        "    emotional = ['paura', 'terrore', 'ansia', 'pianto', 'felice', 'disperato']",
        "    if any(w in lower for w in emotional):",
        "        params['exaggeration'] = 0.68",
        "        params['temperature'] = 0.60",
        "    if len(text) > 350:",
        "        params['temperature'] = 0.52",
        "        params['cfg_weight'] = 0.75",
        "    return params",
        "",
        "# === GENERAZIONE ===",
        "audio_segments = []",
        "failed_chunks = []",
        "",
        "print('\\n' + '='*60)",
        "print('INIZIO GENERAZIONE AUDIO')",
        "print('='*60)",
        "",
        "for idx, chunk in enumerate(chunks):",
        "    print(f'\\n Genero chunk {idx+1}/{len(chunks)}')",
        "    print(f'   {len(chunk.split())} parole, {len(chunk)} caratteri')",
        "    print(f'   Preview: {chunk[:60]}{\"...\" if len(chunk) > 60 else \"\"}')",
        "    try:",
        "        chunk_for_tts = inject_internal_pauses(chunk)",
        "        p = prosody_params(chunk)",
        "        wav = model.generate(",
        "            chunk_for_tts,",
        "            language_id='it',",
        "            audio_prompt_path=AUDIO_PROMPT,",
        "            exaggeration=p['exaggeration'],",
        "            cfg_weight=p['cfg_weight'],",
        "            temperature=p['temperature'],",
        "            min_p=p['min_p'],",
        "            top_p=p['top_p']",
        "        )",
        "        wav = wav / (torch.max(torch.abs(wav)) + 1e-8) * 0.95",
        "        audio_segments.append(wav)",
        "        print('   Generato!')",
        "    except Exception as e:",
        "        print(f'   Errore: {e}')",
        "        failed_chunks.append(idx)",
        "        print('   Retry con parametri conservativi...')",
        "        try:",
        "            wav = model.generate(",
        "                chunk,",
        "                language_id='it',",
        "                audio_prompt_path=AUDIO_PROMPT,",
        "                exaggeration=0.6,",
        "                cfg_weight=0.6,",
        "                temperature=0.55,",
        "                min_p=0.05,",
        "                top_p=0.90",
        "            )",
        "            wav = wav / (torch.max(torch.abs(wav)) + 1e-8) * 0.95",
        "            audio_segments.append(wav)",
        "            print('   Recuperato!')",
        "        except Exception as e2:",
        "            print(f'   Fallito anche con retry: {e2}')",
        "            with open('generation_errors.log', 'a', encoding='utf-8') as f:",
        "                f.write(f'\\n{\"=\"*60}\\n')",
        "                f.write(f'Timestamp: {datetime.datetime.now()}\\n')",
        "                f.write(f'Chunk #{idx+1}\\n')",
        "                f.write(f'Error: {e2}\\n')",
        "                f.write(f'Text: {chunk}\\n')",
        "            continue",
        "",
        "# === SALVATAGGIO ===",
        "print('\\n' + '='*60)",
        "print('SALVATAGGIO')",
        "print('='*60)",
        "",
        "if not audio_segments:",
        "    print('\\nNessun segmento audio generato. Controlla generation_errors.log')",
        "    exit(1)",
        "",
        "if failed_chunks:",
        "    print(f'\\n{len(failed_chunks)} chunk falliti: {failed_chunks}')",
        "",
        "out_dir = pathlib.Path('1.Output')",
        "out_dir.mkdir(exist_ok=True)",
        "",
        "existing = list(out_dir.glob('audiolibro_*.wav'))",
        "num = len(existing) + 1",
        "out_name = out_dir / f'audiolibro_{num:02d}.wav'",
        "",
        "# === PAUSA DINAMICA ===",
        "def dynamic_pause(prev_text):",
        "    text = prev_text.strip()",
        "    lower = text.lower()",
        "    length = len(text)",
        "",
        "    if text.endswith('...'):",
        "        base = 1.3",
        "    elif text.endswith('.') or text.endswith('!') or text.endswith('?'):",
        "        base = 0.85",
        "    elif text.endswith(',') or text.endswith(';') or text.endswith(':'):",
        "        base = 0.35",
        "    else:",
        "        base = 0.18",
        "",
        "    if length > 700:",
        "        base *= 1.55",
        "    elif length > 500:",
        "        base *= 1.35",
        "    elif length > 300:",
        "        base *= 1.20",
        "    elif length < 120:",
        "        base *= 0.85",
        "",
        "    num_sentences = max(1, len([s for s in text.split('.') if s.strip()]))",
        "    if num_sentences >= 5:",
        "        base *= 1.30",
        "    elif num_sentences == 1:",
        "        base *= 0.92",
        "",
        "    if text.startswith(('\"', \"'\")):",
        "        base *= 0.75",
        "",
        "    dialog_verbs = " + pyList(dialogVerbsList),
        "    if any(v in lower for v in dialog_verbs):",
        "        base *= 0.82",
        "",
        "    emotional_words = " + pyList(emotionalWordsList),
        "    if any(w in lower for w in emotional_words):",
        "        base *= 1.18",
        "",
        "    scene_starters = " + pyList(sceneStartersList),
        "    if any(lower.startswith(s) for s in scene_starters):",
        "        base *= 1.25",
        "",
        "    comma_count = text.count(',')",
        "    if comma_count >= 4:",
        "        base *= 1.20",
        "    elif comma_count == 0:",
        "        base *= 0.95",
        "",
        "    longest_sentence = max((len(s) for s in text.split('.') if s.strip()), default=0)",
        "    if longest_sentence > 180:",
        "        base *= 1.25",
        "",
        "    base = max(0.12, min(base, 2.4))",
        "    return base",
        "",
        "# === FADE IN/OUT PER RIDURRE ARTEFATTI ===",
        "def apply_fade(wav, sr, fade_ms=15):",
        "    fade_samples = int(sr * fade_ms / 1000)",
        "    fade_in = torch.linspace(0, 1, fade_samples)",
        "    fade_out = torch.linspace(1, 0, fade_samples)",
        "    wav = wav.clone()",
        "    wav[..., :fade_samples] *= fade_in",
        "    wav[..., -fade_samples:] *= fade_out",
        "    return wav",
        "",
        "# === CONCATENAZIONE CON PAUSA DINAMICA ===",
        "final_segments = []",
        "",
        "for i, seg in enumerate(audio_segments):",
        "    seg = apply_fade(seg, model.sr, fade_ms=18)",
        "    if i > 0:",
        "        pause = dynamic_pause(chunks[i-1])",
        "        silence = torch.zeros((seg.shape[0], int(model.sr * pause)))",
        "        final_segments.append(silence)",
        "    final_segments.append(seg)",
        "",
        "final_audio = torch.cat(final_segments, dim=-1)",
        "final_audio = final_audio / (torch.max(torch.abs(final_audio)) + 1e-8) * 0.95",
        "",
        "ta.save(out_name, final_audio, model.sr)",
        "",
        "duration = final_audio.shape[-1] / model.sr",
        "print(f'\\nFILE CREATO: {out_name}')",
        "print(f'   - Chunk totali: {len(chunks)}')",
        "print(f'   - Chunk riusciti: {len(audio_segments)}')",
        "print(f'   - Chunk falliti: {len(failed_chunks)}')",
        "print(f'   - Durata: {duration:.1f}s ({duration/60:.1f} min)')",
        "print(f'   - Sample rate: {model.sr} Hz')",
        "print('\\nProcesso completato!')",
    ].join("\n");

    const blob = new Blob([script], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'chatterbox_auto.py';
    a.click();

    alert('Script Python esportato!\n\nEsegui: python chatterbox_auto.py');
}

function exportForAcPy() {
    const chunks = window.processedChunks;
    
    const content = chunks.map((chunk, i) => 
        `### CHUNK ${i + 1} ###\n${chunk}`
    ).join('\n\n');
    
    const instructions = `# ISTRUZIONI PER L'USO CON ac.py
# 
# 1. Questo file contiene ${chunks.length} chunk gi√† ottimizzati per Chatterbox
# 2. Ogni chunk √® numerato e separato
# 3. Per usarlo con ac.py:
#    - Copia UN chunk alla volta in testo_da_leggere.txt
#    - Esegui: python ac.py
#    - Ripeti per ogni chunk
#
# OPPURE usa lo script automatico "chatterbox_auto.py"
#
# ============================================================

${content}

# ============================================================
# Fine chunk - Totale: ${chunks.length} chunk
# Parole per chunk: ${chunks.map(c => c.split(/\s+/).length).join(', ')}
# Caratteri per chunk: ${chunks.map(c => c.length).join(', ')}
`;
    
    const blob = new Blob([instructions], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'chunks_per_acpy.txt';
    a.click();
    
    alert(`File creato: chunks_per_acpy.txt\n\nContiene ${chunks.length} chunk numerati.\n\nCopia un chunk alla volta in testo_da_leggere.txt ed esegui ac.py`);
}

function clearAll() {
    document.getElementById('inputText').value = '';
    document.getElementById('statsSection').classList.add('hidden');
    document.getElementById('errorsSection').classList.add('hidden');
    document.getElementById('chunksSection').classList.add('hidden');
    window.processedChunks = [];
}
    </script>
</body>
</html>