<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Panoramica andamento delle mensilit√† di Trading</title>
	<link rel="icon" type="image/png" href="favicon.png"> 
    <style>
      body {
    background: linear-gradient(135deg, #1e1e1e 0%, #2a2a2a 100%);
    font-family: 'Poppins', sans-serif;
    color: #e0e0e0;
    margin: 0;
    padding: 20px;
}

.container {
    max-width: 1300px;
    margin: 0 auto;
    background-color: #2c2c2c;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.6);
}

/* Header */
.header {
    background-color: #222831;
    padding: 5px 5px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.7);
    margin-bottom: 20px;
    width: 100%;
    box-sizing: border-box;
    color: var(--color-heading);
    
}
.header h1 {
    font-size: 2.1em;
    text-align: left;
	margin-left: 20px;
    color: var(--color-heading);
	
}

.card {
    background-color: #3a3a3a;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    padding: 20px;
    margin-bottom: 20px;
}

.footer {
    margin-top: 30px;
    margin-bottom: 10px;
    text-align: center;
    font-size: 16px;
    color: #f2bb66;
    font-weight: normal;
}

.footer a {
    color: #ffe;
    text-decoration: none;
    margin: 0 8px;
    transition: color 0.3s ease;
}

.footer a:hover {
    color: #ffdb58;
}

.dashboard {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
    flex-wrap: wrap;
}

.stats-box {
    flex: 1;
    min-width: 250px;
    padding: 15px;
    border-radius: 10px;
    color: #DDDDDD;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #2E3B4E;
    box-shadow: 0 2px 10px rgba(0,0,0,0.7);
}

.stats-box h3 {
    margin: 0;
    font-size: 16px;
    color: #F2F2F2;
}

.stats-box .value {
    font-size: 28px;
    font-weight: bold;
    color: #FFFFFF;
}

.stats-box .current-value {
    background-color: #4e4e4e;
    color: #ffe58f;
    padding: 10px 30px;
    border-radius: 4px;
}

.stats-box .average-value {
    background-color: #4a5a4a;
    color: #c7ffc7;
    padding: 10px 30px;
    border-radius: 4px;
}

.stats-box .total-value {
    background-color: #5a3a3a;
    color: #ffc7c7;
    padding: 10px 30px;
    border-radius: 4px;
}

.input-section {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
    flex-wrap: wrap;
}

.input-group {
    display: flex;
    gap: 10px;
    flex: 1;
}

input, button {
    padding: 10px;
    border-radius: 4px;
    border: 1px solid #555;
    background-color: #1c1c1c;
    color: #eee;
}

input::placeholder {
    color: #888;
}

input {
    flex: 1;
}

button {
    background-color: #4caf50;
    color: white;
    border: none;
    cursor: pointer;
    font-weight: bold;
    white-space: nowrap;
}

button:hover {
    background-color: #45a049;
}

button.close-month {
    background-color: #f44336;
}

button.close-month:hover {
    background-color: #d32f2f;
}

button.btn-secondary {
    background-color: #2196f3;
}

button.btn-secondary:hover {
    background-color: #0b7dda;
}

button.delete-last {
    background-color: #ff9800;
}

button.delete-last:hover {
    background-color: #e68a00;
}

.file-input {
    flex: 1;
    padding: 8px;
    background-color: #222;
    color: #ddd;
    border: 1px solid #555;
}

.tables-container {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
    flex-wrap: wrap;
}

.table-section {
    flex: 1;
    min-width: 300px;
}

table {
    width: 100%;
    border-collapse: collapse;
    background-color: #2a2a2a;
    color: #f0f0f0;
}

th, td {
    border: 1px solid #444;
    padding: 8px;
    text-align: left;
}

th {
    background-color: #3a3a3a;
    color: #f0f0f0;
}

tr:nth-child(even) {
    background-color: #333;
}

.date-display {
    text-align: left;
    margin-bottom: 20px;
    font-weight: bold;
    color: #ccc;
}

.note {
    font-style: italic;
    margin-bottom: 20px;
    color: #aaa;
}

.error {
    color: #ff6b6b;
    margin-top: 5px;
}

.success {
    color: #66ff99;
    margin-top: 5px;
}

.backup-container {
    display: flex;
    gap: 10px;
    margin-top: 20px;
    align-items: center;
    padding: 15px;
    background-color: #2c2c2c;
    border-radius: 6px;
    border: 1px solid #444;
}

@media (max-width: 768px) {
    .input-section, .backup-container, .input-group {
        flex-direction: column;
    }

    .stats-box, .table-section {
        min-width: 100%;
    }
}

h2 {
    color: #739bf2 !important;
    font-weight: bold !important;
    
    letter-spacing: -0.1px !important;
}

#monthlyChart {
 
  height: 100%; /* oppure: height: 100%; se vuoi adattare anche l'altezza */
  color: #ff6b6b;
  display: block;
  
  box-sizing: border-box;
}



    </style>
	
	<style>
    h1 {
        text-align: center;
        color: #4caf50;
        margin-bottom: 30px;
        font-size: 28px;
    }

    .threshold-inputs {
        display: flex;
        gap: 20px;
        margin-bottom: 30px;
        flex-wrap: wrap;
        justify-content: center;
    }

    .input-group1 {
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-width: 200px;
    }

    .input-group label {
        font-weight: bold;
        color: #fff;
        font-size: 14px;
    }

    .input-group input {
        padding: 12px 15px;
        border: 2px solid #444;
        border-radius: 6px;
        background: #333;
        color: #fff;
        font-size: 16px;
        transition: all 0.3s ease;
    }

    .input-group input:focus {
        outline: none;
        border-color: #4caf50;
        box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
    }

    .input-group input:read-only {
        background: #222;
        cursor: not-allowed;
    }

    .btn-primary {
        background: linear-gradient(45deg, #4caf50, #45a049);
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        transition: all 0.3s ease;
        align-self: end;
    }

    .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
    }

    .current-status {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }

    .status-card {
        background: linear-gradient(135deg, #333, #444);
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        border: 2px solid #555;
        transition: all 0.3s ease;
    }

    .status-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }

    .status-card h3 {
        margin: 0 0 10px 0;
        color: #aaa;
        font-size: 14px;
        font-weight: normal;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .status-card .value {
        color: #4caf50;
        font-size: 24px;
        font-weight: bold;
        margin: 0;
    }

    .threshold-levels {
        background: #333;
        border-radius: 10px;
        padding: 25px;
        margin-bottom: 30px;
        border: 2px solid #444;
    }

    .threshold-levels h2 {
        color: #4caf50;
        margin: 0 0 20px 0;
        text-align: center;
        font-size: 24px;
    }

    .threshold-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
    }

    .threshold-item {
        background: #444;
        padding: 20px;
        border-radius: 8px;
        border-left: 4px solid #666;
        transition: all 0.3s ease;
        position: relative;
    }

    .threshold-item.completed {
        background: linear-gradient(135deg, #1b5e20, #2e7d32);
        border-left-color: #4caf50;
        box-shadow: 0 0 15px rgba(76, 175, 80, 0.2);
    }

    .threshold-item.current {
        background: linear-gradient(135deg, #e65100, #f57c00);
        border-left-color: #ff9800;
        box-shadow: 0 0 15px rgba(255, 152, 0, 0.3);
        animation: pulse 2s infinite;
    }

    .threshold-item.future {
        background: #444;
        border-left-color: #666;
        opacity: 0.7;
    }

    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.02); }
    }

    .threshold-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }

    .threshold-number {
        font-size: 18px;
        font-weight: bold;
        color: #fff;
    }

    .threshold-amount {
        font-size: 20px;
        font-weight: bold;
        color: #4caf50;
    }

    .threshold-details {
        font-size: 14px;
        color: #ccc;
        margin-top: 10px;
    }

    .threshold-details div {
        margin: 5px 0;
    }

    .progress-section {
        background: #333;
        padding: 25px;
        border-radius: 10px;
        margin-bottom: 30px;
        border: 2px solid #444;
    }

    .progress-section h3 {
        color: #4caf50;
        text-align: center;
        margin-bottom: 20px;
        font-size: 20px;
    }

    .progress-bar {
        width: 100%;
        height: 40px;
        background: #444;
        border-radius: 20px;
        overflow: hidden;
        position: relative;
        margin-bottom: 15px;
    }

    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #4caf50, #45a049);
        border-radius: 20px;
        transition: width 0.5s ease;
        position: relative;
    }

    .progress-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-weight: bold;
        font-size: 16px;
        color: #fff;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
    }

    .alert {
        padding: 15px;
        border-radius: 6px;
        margin-bottom: 20px;
        font-weight: bold;
        text-align: center;
    }

    .alert-success {
        background: rgba(76, 175, 80, 0.2);
        border: 1px solid #4caf50;
        color: #4caf50;
    }

    .alert-warning {
        background: rgba(255, 152, 0, 0.2);
        border: 1px solid #ff9800;
        color: #ff9800;
    }

    .alert-error {
        background: rgba(244, 67, 54, 0.2);
        border: 1px solid #f44336;
        color: #f44336;
    }

    .hidden {
        display: none;
    }

    .trade-limits {
        background: #333;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
        border: 2px solid #444;
    }

    .trade-limits h3 {
        color: #4caf50;
        margin-bottom: 15px;
        text-align: center;
    }

    .limits-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
    }

    .limit-item {
        background: #444;
        padding: 15px;
        border-radius: 8px;
        text-align: center;
    }

    .limit-item .label {
        font-size: 12px;
        color: #aaa;
        margin-bottom: 5px;
    }

    .limit-item .value {
        font-size: 16px;
        font-weight: bold;
        color: #fff;
    }

    /* Spazio tra card */
    .card-space {
        height: 36px;
        width: 100%;
        display: block;
    }
	
	.threshold-amount {
    color: #fff;
}

</style>

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Operativit√† di Trading</h1>
        </div>
        
        <div class="date-display">
            Dal <span id="currentDate">09.05.2025</span>
        </div>
        
        <div class="note">
            Nota: Visita la <a href="panoramica-capitale.html" target="_blank">Panoramica Capitale</a> per informazioni dettagliate sul tuo trading.
        </div>
        
        <div class="note">
            La quota in mese corrente, √® il guadagno da ritirare come tua mensilit√†, rispetto al tuo capitale e dal tuo trading.
        </div>
        
        <div class="dashboard">
            <div class="stats-box current">
                <h3>Mese corrente</h3>
                <div class="value current-value" id="currentMonthValue">0,00</div>
            </div>
            <div class="stats-box average">
                <h3>Media Mensilit√†</h3>
                <div class="value average-value" id="monthlyAverage">0,00</div>
            </div>
            <div class="stats-box total">
                <h3>Totale Earn</h3>
                <div class="value total-value" id="totalEarn">0,00</div>
            </div>
        </div>
        
        <div class="input-section">
            <div class="input-group">
                <input type="number" id="importInput" placeholder="Inserisci importo (es. 1,95)" step="0.01">
                <button id="addButton">Aggiungi Importo</button>
                <button id="deleteLastButton" class="delete-last">Cancella Ultimo</button>
                <button id="closeMonthButton" class="close-month">Chiudi Mese</button>
            </div>
        </div>
        
        <div class="tables-container">
            <div class="table-section">
                <h2>Importi Mese Corrente</h2>
                <table id="currentMonthTable">
                    <thead>
                        <tr>
                            <th>Data</th>
                            <th>Importo</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Contenuto dinamico -->
                    </tbody>
                </table>
            </div>
            
            <div class="table-section">
                <h2>Storico Mensile</h2>
                <table id="historicalTable">
                    <thead>
                        <tr>
                            <th>Periodo</th>
                            <th>Importo</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Contenuto dinamico -->
                    </tbody>
                </table>
            </div>
        </div>
        
     
		
    
	
	 <div class="backup-container">
        
        <h2>Grafico Storico Mensile</h2>
    <canvas id="monthlyChart" width="800" height="400"></canvas>
    <div style="display: flex; gap: 10px; margin-top: 15px;">
	
        <button id="downloadChartBtn" class="btn-secondary">Scarica Grafico</button>
        <button id="downloadTableBtn" class="btn-secondary">Scarica Tabella</button>
    </div>
	</div>
	


   <div class="backup-container">
            <button id="scaricaDatiBtn" class="btn-secondary">Scarica Dati (JSON)</button>
            <input type="file" id="fileInput" class="file-input" accept=".json">
            <label for="fileInput" class="btn-secondary" style="cursor: pointer;">Seleziona File</label>
            <button id="caricaDatiBtn">Carica Dati</button>
        </div>
        
        <div id="message"></div>
		</div>
		
		</div>
		
		<div style="height: 28px;"></div>
	<div class="container">
    <h1>üöÄ Sistema di Soglie Incrementale Trading</h1>
    
    <div class="threshold-inputs">
        <div class="input-group1">
            <label for="initialCapital">Capitale Iniziale ($)</label>
            <input type="number" id="initialCapital" value="6000" min="1000" step="100">
        </div>
        
        <div class="input-group1">
            <label for="currentEarnings">Guadagni Attuali ($)</label>
            <input type="number" id="currentEarnings" readonly style="background: #323b45; color: #e9ecef; cursor: not-allowed;" placeholder="Auto-calcolato">
        </div>
        
        <div class="input-group1">
            <label for="tradesCompleted">Trade Completati</label>
            <input type="number" id="tradesCompleted" readonly style="background: #323b45; color: #e9ecef; cursor: not-allowed;" placeholder="Auto-calcolato">
        </div>
        
        <button id="calculateBtn" class="btn-primary">Aggiorna Sistema</button>
    </div>

    <div id="alertContainer"></div>
    
    <div id="resultsContainer" class="hidden">
        <div class="current-status">
            <div class="status-card">
                <h3>Capitale Attuale</h3>
                <div class="value" id="currentCapital">$0</div>
            </div>
            <div class="status-card">
                <h3>Soglia Attuale</h3>
                <div class="value" id="currentThreshold">Soglia 1</div>
            </div>
            <div class="status-card">
                <h3>Progresso</h3>
                <div class="value" id="progressPercent">0%</div>
            </div>
            <div class="status-card">
                <h3>% Total Earn</h3>
                <div class="value" id="totalEarnPercent">0%</div>
            </div>
        </div>

        <div class="progress-section">
            <h3>Progresso verso Prossima Soglia</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                <div class="progress-text" id="progressText">0%</div>
            </div>
        </div>

        <div class="trade-limits">
            <h3>Limiti di Trading</h3>
            <div class="limits-grid">
                <div class="limit-item">
                    <div class="label">Trade Totali</div>
                    <div class="value" id="remainingTrades">30</div>
                </div>
                <div class="limit-item">
                    <div class="label">Valore per Trade</div>
                    <div class="value" id="tradeValue">$0</div>
                </div>
                <div class="limit-item">
                    <div class="label">Capitale Target</div>
                    <div class="value" id="targetCapital">$0</div>
                </div>
                <div class="limit-item">
                    <div class="label">% Guadagno Richiesto</div>
                    <div class="value" id="requiredGainPercent">0%</div>
                </div>
            </div>
        </div>

        <div class="threshold-levels">
            <h3>üìä Soglie di Crescita</h3>
            <div class="threshold-grid" id="thresholdGrid">
                <!-- Le soglie verranno generate dinamicamente -->
            </div>
        </div>
        <div class="threshold-levels">
            <h3>üí∏ Storico Ritiro e Reinvestimento</h3>
            <div id="withdrawalHistory"></div>
            <div id="reinvestedHistory"></div>
        </div>
    </div>
</div>


	
	

	<div class="footer">
            Trading Spot Manager v1.1 | 
            <a href="https://beneinst.github.io/tradingspot/index.html">Operativit√†</a> | 
            <a href="https://beneinst.github.io/tradingspot/panoramica-capitale.html">Capitale</a> | 
			<a href="https://beneinst.github.io/tradingspot/trade.html">Trade</a> |
            <a href="https://beneinst.github.io/tradingspot/blocco-note.html">Note</a> | 
            <a href="https://beneinst.github.io/tradingspot/chartflow/index.html">Segnali</a> |
            <a href="https://beneinst.github.io/tradingspot/Strategia-Trading.html">Indicatore</a> | 
            <a href="https://beneinst.github.io/tradingspot/regole-trading.html">Regole</a> |
            <a href="https://beneinst.github.io/tradingspot/candlestick.html">Candlestick</a> | 
            <a href="https://beneinst.github.io/tradingspot/cheat-sheet.html">Patterns</a>
        </div>
    </div>

<script>
// --- CONFIGURAZIONE SOGLIE PROGRESSIVE (con reinvestimento del 40%) ---
const REINVEST_PERCENT = 0.4; // 40% del profitto viene reinvestito
const THRESHOLD_PERCENTS = [
    { level: 1, percent: 0.19, description: "Soglia Base - Crescita del 19%" },
    { level: 2, percent: 0.49, description: "Soglia Intermedia - Crescita del 49%" },
    { level: 3, percent: 0.86, description: "Soglia Avanzata - Crescita del 86%" },
    { level: 4, percent: 1.23, description: "Soglia Professionale - Crescita del 123%" },
    { level: 5, percent: 1.98, description: "Soglia Elite - Crescita del 198%" }
];

const MAX_TRADES = 30;

// Storico dei ritiri e dei reinvestimenti
let withdrawalHistory = [];
let reinvestedHistory = [];

// Funzioni per integrare con il sistema esistente
function calculateTotalEarned() {
    if (typeof historicalEntries !== 'undefined' && typeof currentMonthEntries !== 'undefined') {
        const historicalSum = historicalEntries.reduce((acc, entry) => acc + parseFloat(entry.importo), 0);
        const currentSum = currentMonthEntries.reduce((acc, entry) => acc + parseFloat(entry.importo), 0);
        return historicalSum + currentSum;
    }
    return 0;
}

function getTotalTradesCount() {
    if (typeof window.tradeClickCount !== 'undefined') {
        return window.tradeClickCount;
    }
    if (typeof currentMonthEntries !== 'undefined' && typeof historicalEntries !== 'undefined') {
        return currentMonthEntries.length + historicalEntries.length;
    }
    return 0;
}

// Inizializza il contatore dei trade se non esiste
if (typeof window.tradeClickCount === 'undefined') {
    window.tradeClickCount = 0;
}

// Intercetta i click del pulsante addButton se esiste
function setupTradeCounter() {
    const addButton = document.getElementById('addButton');
    if (addButton) {
        addButton.addEventListener('click', function() {
            window.tradeClickCount++;
            if (!document.getElementById('resultsContainer').classList.contains('hidden')) {
                setTimeout(calculateThresholds, 500);
            }
        });
    }
}

let currentData = {
    initialCapital: 6000,
    currentEarnings: 0,
    tradesCompleted: 0,
    currentCapital: 6000,
    currentThresholdIndex: 0
};

function showAlert(message, type = 'success') {
    const alertContainer = document.getElementById('alertContainer');
    const alert = document.createElement('div');
    alert.className = `alert alert-${type}`;
    alert.innerHTML = message;
    alertContainer.innerHTML = '';
    alertContainer.appendChild(alert);
    setTimeout(() => {
        alert.remove();
    }, 5000);
}

function formatCurrency(amount) {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
    }).format(amount);
}

// --- GENERA SOGLIE PROGRESSIVE CON REINVESTIMENTO PARZIALE ---
function generateThresholdProgressive(initialCapital) {
    let thresholds = [];
    let baseCapital = initialCapital;

    for (let i = 0; i < THRESHOLD_PERCENTS.length; i++) {
        const config = THRESHOLD_PERCENTS[i];
        const profitTarget = baseCapital * config.percent;
        const reinvest = profitTarget * REINVEST_PERCENT;
        const withdrawal = profitTarget - reinvest;
        const targetCapital = baseCapital + profitTarget;

        thresholds.push({
            level: config.level,
            baseCapital: baseCapital,
            profitTarget: profitTarget,
            reinvest: reinvest,
            withdrawal: withdrawal,
            targetCapital: targetCapital,
            tradeValue: Math.round(baseCapital / MAX_TRADES),
	// per quota trade da capitale iniziale		tradeValue: Math.round(initialCapital / MAX_TRADES)
            maxTrades: MAX_TRADES,
            description: config.description
        });

        // Solo la quota reinvestita va aggiunta al capitale per la soglia successiva
        baseCapital = baseCapital + reinvest;
    }
    return thresholds;
}

function getCurrentThreshold() {
    const capital = currentData.currentCapital;
    const thresholds = generateThresholdProgressive(currentData.initialCapital);
    for (let i = 0; i < thresholds.length; i++) {
        if (capital < thresholds[i].targetCapital) {
            return i;
        }
    }
    return thresholds.length - 1;
}

function calculateProgress() {
    const thresholdIndex = getCurrentThreshold();
    const thresholds = generateThresholdProgressive(currentData.initialCapital);
    const currentThreshold = thresholds[thresholdIndex];
    const capital = currentData.currentCapital;
    if (thresholdIndex === 0) {
        const progress = ((capital - currentThreshold.baseCapital) / (currentThreshold.targetCapital - currentThreshold.baseCapital)) * 100;
        return Math.max(0, Math.min(100, progress));
    } else {
        const prevThreshold = thresholds[thresholdIndex - 1];
        const progress = ((capital - prevThreshold.targetCapital) / (currentThreshold.targetCapital - prevThreshold.targetCapital)) * 100;
        return Math.max(0, Math.min(100, progress));
    }
}

function calculateTotalEarnPercent() {
    const earnPercent = (currentData.currentEarnings / currentData.initialCapital) * 100;
    return Math.max(0, earnPercent);
}

// Funzione per gestire ritiro e reinvestimento alla soglia
function handleThresholdReached(thresholdIndex) {
    const thresholds = generateThresholdProgressive(currentData.initialCapital);
    const currentThreshold = thresholds[thresholdIndex];
    const baseCapital = currentThreshold.baseCapital;
    const targetCapital = currentThreshold.targetCapital;
    const actualCapital = currentData.currentCapital;

    // Calcola profitto realizzato
    const profit = Math.max(0, actualCapital - baseCapital);

    // Calcola quota reinvestibile (es. 40%)
    const reinvest = profit * REINVEST_PERCENT;
    const toWithdraw = profit - reinvest;

    // Aggiorna storico
    withdrawalHistory.push({
        level: currentThreshold.level,
        amount: toWithdraw,
        date: new Date().toLocaleDateString()
    });
    reinvestedHistory.push({
        level: currentThreshold.level,
        amount: reinvest,
        date: new Date().toLocaleDateString()
    });

    // Aggiorna capitale operativo per la soglia successiva
    currentData.initialCapital = baseCapital + reinvest;
    currentData.currentEarnings = actualCapital - currentData.initialCapital;
    currentData.currentCapital = actualCapital;

    // Mostra alert
    showAlert(
        `Soglia ${currentThreshold.level} raggiunta! Profitto: ${formatCurrency(profit)}. 
        <br>Ritirato: <b>${formatCurrency(toWithdraw)}</b> | Reinvestito: <b>${formatCurrency(reinvest)}</b>.<br>
        Il nuovo capitale operativo per la prossima soglia √® ${formatCurrency(currentData.initialCapital)}.`,
        'success'
    );
    updateHistoryDisplay();
}

function updateDisplay() {
    const thresholdIndex = getCurrentThreshold();
    const thresholds = generateThresholdProgressive(currentData.initialCapital);
    const currentThreshold = thresholds[thresholdIndex];
    const progress = calculateProgress();
    const totalEarnPercent = calculateTotalEarnPercent();
    const remainingTrades = Math.max(0, currentThreshold.maxTrades - currentData.tradesCompleted);
    const requiredGainPercent = ((currentThreshold.targetCapital - currentThreshold.baseCapital) / currentThreshold.baseCapital) * 100;

    // Aggiorna status cards
    document.getElementById('currentCapital').textContent = formatCurrency(currentData.currentCapital);
    document.getElementById('currentThreshold').textContent = `Soglia ${currentThreshold.level}`;
    document.getElementById('progressPercent').textContent = `${progress.toFixed(1)}%`;
    document.getElementById('totalEarnPercent').textContent = `${totalEarnPercent.toFixed(1)}%`;

    // Aggiorna progress bar
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    progressFill.style.width = `${progress}%`;
    progressText.textContent = `${progress.toFixed(1)}%`;

    // Aggiorna limiti di trading
    document.getElementById('remainingTrades').textContent = remainingTrades;
    document.getElementById('tradeValue').textContent = formatCurrency(currentThreshold.tradeValue);
    document.getElementById('targetCapital').textContent = formatCurrency(currentThreshold.targetCapital);
    document.getElementById('requiredGainPercent').textContent = `${requiredGainPercent.toFixed(1)}%`;

    // Aggiorna griglia soglie
    updateThresholdGrid();

    // Controlli e avvisi
    if (remainingTrades <= 0) {
        showAlert('‚ö†Ô∏è Limite di trade raggiunto per questa soglia! Considera di passare alla soglia successiva.', 'warning');
    }

    if (progress >= 100) {
        if (thresholdIndex < thresholds.length - 1) {
            handleThresholdReached(thresholdIndex);
            showAlert('üéâ Congratulazioni! Hai raggiunto la soglia corrente. Puoi passare alla soglia successiva!', 'success');
        } else {
            handleThresholdReached(thresholdIndex);
            showAlert('üèÜ Eccellente! Hai raggiunto la soglia massima del sistema!', 'success');
        }
    }
}

function updateThresholdGrid() {
    const grid = document.getElementById('thresholdGrid');
    const currentThresholdIndex = getCurrentThreshold();
    const thresholds = generateThresholdProgressive(currentData.initialCapital);

    grid.innerHTML = '';

    thresholds.forEach((threshold, index) => {
        const item = document.createElement('div');
        item.className = 'threshold-item';

        if (index < currentThresholdIndex) {
            item.classList.add('completed');
        } else if (index === currentThresholdIndex) {
            item.classList.add('current');
        } else {
            item.classList.add('future');
        }

        const progress = index === currentThresholdIndex ? calculateProgress() : 0;
        const earnPercent = (threshold.profitTarget / threshold.baseCapital) * 100;
        const status = index < currentThresholdIndex ? '‚úÖ Completata' :
            index === currentThresholdIndex ? `üéØ Attuale (${progress.toFixed(1)}%)` :
                '‚è≥ Futura';

        item.innerHTML = `
            <div class="threshold-info">
                <div class="threshold-number">Soglia ${threshold.level}</div>
                <div class="threshold-amount">${formatCurrency(threshold.targetCapital)}</div>
            </div>
            <div class="threshold-details">
                <div><strong>Capitale Base:</strong> ${formatCurrency(threshold.baseCapital)}</div>
                <div><strong>Profitto Richiesto:</strong> ${formatCurrency(threshold.profitTarget)} (${earnPercent.toFixed(1)}%)</div>
                <div><strong>Quota Reinvestita:</strong> ${formatCurrency(threshold.reinvest)}</div>
                <div><strong>Quota Ritirabile:</strong> ${formatCurrency(threshold.withdrawal)}</div>
                <div><strong>Valore Trade:</strong> ${formatCurrency(threshold.tradeValue)}</div>
                <div><strong>Max Trade:</strong> ${threshold.maxTrades}</div>
                <div><strong>Status:</strong> ${status}</div>
                <div style="margin-top: 10px; font-style: italic; color: #6CC417;">${threshold.description}</div>
            </div>
        `;

        grid.appendChild(item);
    });
}

function updateHistoryDisplay() {
    const withdrawalDiv = document.getElementById('withdrawalHistory');
    const reinvestedDiv = document.getElementById('reinvestedHistory');
    if (withdrawalDiv) {
        withdrawalDiv.innerHTML = '<b>Ritiri:</b><br>' + withdrawalHistory.map(w =>
            `Soglia ${w.level}: ${formatCurrency(w.amount)} (${w.date})`
        ).join('<br>');
    }
    if (reinvestedDiv) {
        reinvestedDiv.innerHTML = '<b>Reinvestiti:</b><br>' + reinvestedHistory.map(r =>
            `Soglia ${r.level}: ${formatCurrency(r.amount)} (${r.date})`
        ).join('<br>');
    }
}

function calculateThresholds() {
    const initialCapital = parseFloat(document.getElementById('initialCapital').value) || 6000;
    const currentEarnings = calculateTotalEarned();
    const tradesCompleted = getTotalTradesCount();

    // Aggiorna i campi di input
    document.getElementById('initialCapital').value = initialCapital;
    document.getElementById('currentEarnings').value = currentEarnings.toFixed(2);
    document.getElementById('tradesCompleted').value = tradesCompleted;

    // Aggiorna i dati correnti
    currentData.initialCapital = initialCapital;
    currentData.currentEarnings = currentEarnings;
    currentData.tradesCompleted = tradesCompleted;
    currentData.currentCapital = initialCapital + currentEarnings;

    // Mostra i risultati
    document.getElementById('resultsContainer').classList.remove('hidden');

    // Aggiorna il display
    updateDisplay();

    showAlert('‚úÖ Sistema di soglie aggiornato con successo!', 'success');
}

// Funzione per aggiornare automaticamente
function updateThresholdSystem() {
    calculateThresholds();
}

// Auto-aggiorna al caricamento
function autoUpdateOnLoad() {
    setTimeout(() => {
        setupTradeCounter();
        calculateThresholds();
    }, 1000);
}

// Event listeners
document.getElementById('calculateBtn').addEventListener('click', calculateThresholds);
document.getElementById('initialCapital').addEventListener('input', calculateThresholds);
document.getElementById('tradesCompleted').addEventListener('input', calculateThresholds);


// Auto-carica al caricamento della pagina
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', autoUpdateOnLoad);
} else {
    autoUpdateOnLoad();
}

// Espone le funzioni per l'integrazione esterna
window.updateThresholdSystem = updateThresholdSystem;
window.setupTradeCounter = setupTradeCounter;
</script>



    <script>
        // Inizializzazione delle variabili
        let currentMonthEntries = [];
        let historicalEntries = [];
        
        // Caricare dati da localStorage se disponibili
        function loadFromLocalStorage() {
            const savedCurrentEntries = localStorage.getItem('currentMonthEntries');
            const savedHistoricalEntries = localStorage.getItem('historicalEntries');
            
            if (savedCurrentEntries) {
                currentMonthEntries = JSON.parse(savedCurrentEntries);
            }
            
            if (savedHistoricalEntries) {
                historicalEntries = JSON.parse(savedHistoricalEntries);
            }
        }
        
        // Salvare dati nel localStorage
        function saveToLocalStorage() {
            localStorage.setItem('currentMonthEntries', JSON.stringify(currentMonthEntries));
            localStorage.setItem('historicalEntries', JSON.stringify(historicalEntries));
        }
        
        // Funzione per formattare le date nel formato italiano
        function formatDate(date) {
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = String(date.getFullYear()).slice(-2);
            return `${day}.${month}.${year}`;
        }
        
        // Funzione per formattare gli importi
        function formatImport(value) {
            return parseFloat(value).toFixed(2).replace('.', ',');
        }
        
        // Funzione per ottenere la data attuale
        function getCurrentDate() {
            const now = new Date();
            return formatDate(now);
        }
        
        // Aggiornare la data corrente
        document.getElementById('currentDate').textContent = getCurrentDate();
        
        // Funzione per calcolare la media degli importi mensili
        function calculateMonthlyAverage() {
            if (historicalEntries.length === 0) {
                return 0;
            }
            const sum = historicalEntries.reduce((acc, entry) => acc + parseFloat(entry.importo), 0);
            return sum / historicalEntries.length;
        }
        
        // Funzione per calcolare il totale guadagnato
        function calculateTotalEarned() {
            const historicalSum = historicalEntries.reduce((acc, entry) => acc + parseFloat(entry.importo), 0);
            const currentSum = currentMonthEntries.reduce((acc, entry) => acc + parseFloat(entry.importo), 0);
            return historicalSum + currentSum;
        }
        
        // Funzione per calcolare il valore del mese corrente
        function calculateCurrentMonthValue() {
            return currentMonthEntries.reduce((acc, entry) => acc + parseFloat(entry.importo), 0);
        }
        
        // Funzione per aggiornare le dashboard
        function updateDashboard() {
            const currentMonthValue = calculateCurrentMonthValue();
            const monthlyAverage = calculateMonthlyAverage();
            const totalEarn = calculateTotalEarned();
            
            document.getElementById('currentMonthValue').textContent = formatImport(currentMonthValue);
            document.getElementById('monthlyAverage').textContent = formatImport(monthlyAverage);
            document.getElementById('totalEarn').textContent = formatImport(totalEarn);
        }
        
        // Funzione per aggiornare la tabella del mese corrente
        function updateCurrentMonthTable() {
            const tableBody = document.querySelector('#currentMonthTable tbody');
            tableBody.innerHTML = '';
            
            currentMonthEntries.forEach(entry => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${entry.data}</td>
                    <td>${formatImport(entry.importo)}</td>
                `;
                tableBody.appendChild(row);
            });
        }
        
        // Funzione per aggiornare la tabella storica
        function updateHistoricalTable() {
            const tableBody = document.querySelector('#historicalTable tbody');
            tableBody.innerHTML = '';
            
            historicalEntries.forEach(entry => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${entry.periodo}</td>
                    <td>${formatImport(entry.importo)}</td>
                `;
                tableBody.appendChild(row);
            });
        }
        
       // Soluzione completa per il problema delle date

// Funzione per convertire una data in formato italiano (gg.mm.aa) a oggetto Date
function parseItalianDate(dateStr) {
    const [day, month, year] = dateStr.trim().split('.');
    return new Date(`20${year}`, parseInt(month) - 1, parseInt(day));
}

// Funzione corretta per generare il periodo mensile
function generateMonthlyPeriod() {
    const today = new Date();
    
    // Se ci sono entry storiche, prendiamo l'ultimo periodo e calcoliamo la data di inizio
    // come giorno successivo alla data di fine dell'ultimo periodo
    let startDate;
    
    if (historicalEntries.length > 0) {
        const lastPeriod = historicalEntries[historicalEntries.length - 1].periodo;
        // Estrai la data di fine (parte dopo "al ")
        const endDateStr = lastPeriod.split("al ")[1].trim();
        
        // Converti da formato italiano (gg.mm.aa) a Date
        const endDate = parseItalianDate(endDateStr);
        
        // La data di inizio √® il giorno successivo
        startDate = new Date(endDate);
        startDate.setDate(startDate.getDate() + 1);
    } else {
        // Se non ci sono entry storiche, prendiamo il primo giorno del mese corrente
        startDate = new Date(today.getFullYear(), today.getMonth(), 1);
    }
    
    // Data di fine √® la data corrente
    const endDate = new Date(today);
    
    // Formattare le date
    const formattedStartDate = formatDate(startDate);
    const formattedEndDate = formatDate(endDate);
    
    return `dal ${formattedStartDate} al ${formattedEndDate}`;
}

// Funzione aggiuntiva per debugging che pu√≤ aiutarti a verificare i periodi
function validateHistoricalPeriods() {
    if (historicalEntries.length <= 1) return true; // Non c'√® abbastanza storia da validare
    
    let isValid = true;
    let errors = [];
    
    for (let i = 1; i < historicalEntries.length; i++) {
        const prevPeriod = historicalEntries[i-1].periodo;
        const currPeriod = historicalEntries[i].periodo;
        
        // Estrai le date di fine del periodo precedente
        const prevEndDateStr = prevPeriod.split("al ")[1].trim();
        const prevEndDate = parseItalianDate(prevEndDateStr);
        
        // Estrai la data di inizio del periodo corrente
        const currStartDateStr = currPeriod.split("dal ")[1].split(" al")[0].trim();
        const currStartDate = parseItalianDate(currStartDateStr);
        
        // Calcola la data che dovrebbe essere l'inizio del periodo corrente (giorno dopo la fine del precedente)
        const expectedStartDate = new Date(prevEndDate);
        expectedStartDate.setDate(expectedStartDate.getDate() + 1);
        
        // Verifica che la data di inizio corrente sia il giorno successivo alla fine del precedente
        if (currStartDate.getTime() !== expectedStartDate.getTime()) {
            isValid = false;
            errors.push(`Errore tra periodi ${i-1} e ${i}: ${formatDate(expectedStartDate)} != ${currStartDateStr}`);
        }
    }
    
    if (!isValid) {
        console.error("Errori nei periodi storici:", errors);
    }
    
    return isValid;
}

// Funzione per correggere manualmente i periodi storici
function fixHistoricalPeriods() {
    if (historicalEntries.length <= 0) return; // Nessun dato da correggere
    
    // Ordinare le entry per periodo (se necessario)
    // Le ordiniamo in base alla data di fine per assicurarci che siano cronologiche
    historicalEntries.sort((a, b) => {
        const dateA = parseItalianDate(a.periodo.split("al ")[1].trim());
        const dateB = parseItalianDate(b.periodo.split("al ")[1].trim());
        return dateA - dateB;
    });
    
    // Correzione dei periodi
    for (let i = 1; i < historicalEntries.length; i++) {
        const prevPeriod = historicalEntries[i-1].periodo;
        
        // Estrai la data di fine del periodo precedente
        const prevEndDateStr = prevPeriod.split("al ")[1].trim();
        const prevEndDate = parseItalianDate(prevEndDateStr);
        
        // La data di inizio corrente dovrebbe essere il giorno successivo
        const startDate = new Date(prevEndDate);
        startDate.setDate(startDate.getDate() + 1);
        
        // Estrai la data di fine del periodo corrente
        const endDateStr = historicalEntries[i].periodo.split("al ")[1].trim();
        const endDate = parseItalianDate(endDateStr);
        
        // Aggiorna il periodo con la data di inizio corretta
        historicalEntries[i].periodo = `dal ${formatDate(startDate)} al ${formatDate(endDate)}`;
    }
    
    // Salva le modifiche
    saveToLocalStorage();
    
    // Aggiorna l'interfaccia
    updateHistoricalTable();
    
    return {
        message: "Periodi corretti con successo",
        entries: historicalEntries
    };
}

// Funzione per correggere un database esistente (da chiamare da console)
function fixDatabase() {
    try {
        // Prima carichiamo i dati
        loadFromLocalStorage();
        
        // Correzione periodi
        const result = fixHistoricalPeriods();
        
        // Aggiorniamo tutto
        updateAll();
        
        return {
            success: true,
            message: "Database corretto con successo",
            result: result
        };
    } catch (error) {
        return {
            success: false,
            message: "Errore durante la correzione",
            error: error.message
        };
    }
}

function downloadTableBtn() {
    if (!chartData || chartData.length === 0) {
        showMessage('Nessun dato disponibile per la tabella!', 'error');
        return;
    }

    // Determina l'etichetta della prima colonna
    let firstColumnLabel = "Giorno";
    modeRadios.forEach(radio => {
        if (radio.checked) {
            if (radio.value === "giorno") {
                firstColumnLabel = "Giorno";
            } else if (radio.value === "area") {
                firstColumnLabel = "Area";
            } else if (radio.value === "custom") {
                firstColumnLabel = customLabelInput.value || "Codice";
            }
        }
    });

    // Prepara i dati CSV
    let csv = `${firstColumnLabel},Media Giornaliera (Fks),Valore (Fk Polo 18),Fk / Valore\n`;
    let sumFk = 0, sumValore = 0;

    chartData.forEach(item => {
        csv += `${item.identifier},${item.fk.toFixed(3)},${item.valore.toFixed(2)},${item.fk.toFixed(3)} / ${item.valore.toFixed(2)}\n`;
        sumFk += item.fk;
        sumValore += item.valore;
    });

    // Riga media
    const avgFk = sumFk / chartData.length;
    const avgValore = sumValore / chartData.length;
    csv += `Media,${avgFk.toFixed(3)},${avgValore.toFixed(2)},${avgFk.toFixed(3)} / ${avgValore.toFixed(2)}\n`;

    // Download CSV
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `tabella_valori_${getCurrentDate().replace(/\./g, '-')}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);

    showMessage('Tabella CSV scaricata con successo!', 'success');
}

        
// Funzione modificata per chiudere il mese
function closeMonth() {
    if (currentMonthEntries.length === 0) {
        showMessage('Non ci sono importi da registrare per questo mese!', 'error');
        return;
    }
    
    // Chiediamo input per le date tramite prompt del browser
    const startDateStr = prompt("Inserisci la data di inizio (formato GG.MM.AA):", "");
    if (!startDateStr) return; // L'utente ha annullato
    
    const endDateStr = prompt("Inserisci la data di fine (formato GG.MM.AA):", getCurrentDate());
    if (!endDateStr) return; // L'utente ha annullato
    
    // Verifica che le date siano nel formato corretto
    if (!isValidDateFormat(startDateStr) || !isValidDateFormat(endDateStr)) {
        showMessage('Il formato delle date deve essere GG.MM.AA!', 'error');
        return;
    }
    
    // Calcoliamo la media degli importi del mese corrente
    const totalMonthValue = calculateCurrentMonthValue();
    
    // Creiamo una nuova entry per lo storico
    const newHistoricalEntry = {
        periodo: `dal ${startDateStr} al ${endDateStr}`,
        importo: totalMonthValue
    };
    
    // Aggiungiamo l'entry allo storico
    historicalEntries.push(newHistoricalEntry);
    
    // Resettiamo gli importi del mese corrente
    currentMonthEntries = [];
    
    // Salviamo nel localStorage
    saveToLocalStorage();
    
    // Aggiorniamo l'interfaccia
    updateAll();
    
    showMessage('Mese chiuso con successo!', 'success');
}

// Funzione per verificare il formato della data
function isValidDateFormat(dateStr) {
    // Verifica che la data sia nel formato GG.MM.AA
    const regex = /^\d{2}\.\d{2}\.\d{2}$/;
    return regex.test(dateStr);
}

// Funzione per aggiungere un importo
function addImport() {
    const importInput = document.getElementById('importInput');
    const importo = parseFloat(importInput.value.replace(',', '.'));
    
    if (isNaN(importo) || importo <= 0) {
        showMessage('Inserisci un importo valido!', 'error');
        return;
    }
    
    // Aggiungiamo l'importo alla lista del mese corrente
    currentMonthEntries.push({
        data: getCurrentDate(),
        importo: importo
    });
    
    // Salviamo nel localStorage
    saveToLocalStorage();
    
    // Aggiorniamo l'interfaccia
    updateAll();
    
    // Puliamo l'input
    importInput.value = '';
    
    showMessage('Importo aggiunto con successo!', 'success');
}

// Funzione per eliminare l'ultimo dato inserito
function deleteLastEntry() {
    if (currentMonthEntries.length === 0) {
        showMessage('Non ci sono importi da cancellare!', 'error');
        return;
    }
    
    // Rimuoviamo l'ultimo elemento
    const removedEntry = currentMonthEntries.pop();
    
    // Salviamo nel localStorage
    saveToLocalStorage();
    
    // Aggiorniamo l'interfaccia
    updateAll();
    
    showMessage(`Ultimo importo (${formatImport(removedEntry.importo)}) cancellato con successo!`, 'success');
}

// Funzione per mostrare messaggi
function showMessage(text, type) {
    const messageDiv = document.getElementById('message');
    messageDiv.textContent = text;
    messageDiv.className = type; // 'error' o 'success'
    
    // Rimuoviamo il messaggio dopo 5 secondi
    setTimeout(() => {
        messageDiv.textContent = '';
        messageDiv.className = '';
    }, 5000);
}

// Funzione aggiornata per esportare i dati
function scaricaDati() {
    const data = {
        currentMonthEntries,
        historicalEntries
    };
    
    const dataStr = JSON.stringify(data, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `trading_backup_${getCurrentDate().replace(/\./g, '-')}.json`;
    link.click();
    
    URL.revokeObjectURL(url);
    
    showMessage('Backup effettuato con successo!', 'success');
}

// Funzione per importare i dati
function caricaDati() {
    const fileInput = document.getElementById('fileInput');
    if (fileInput.files.length === 0) {
        showMessage('Seleziona un file da caricare', 'error');
        return;
    }
    
    const file = fileInput.files[0];
    const reader = new FileReader();
    
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            
            if (data.currentMonthEntries && data.historicalEntries) {
                currentMonthEntries = data.currentMonthEntries;
                historicalEntries = data.historicalEntries;
                
                // Salviamo nel localStorage
                saveToLocalStorage();
                
                // Aggiorniamo l'interfaccia
                updateAll();
                
                showMessage('Dati ripristinati con successo!', 'success');
            } else {
                showMessage('Il file di backup non √® valido!', 'error');
            }
        } catch (err) {
            showMessage('Errore durante il caricamento del backup: ' + err.message, 'error');
        }
        
        // Reset del file input
        fileInput.value = '';
    };
    
    reader.readAsText(file);
}

// Funzione per aggiornare tutto
function updateAll() {
    updateCurrentMonthTable();
    updateHistoricalTable();
    updateDashboard();
}

// Event listener per aggiungere un importo
document.getElementById('addButton').addEventListener('click', addImport);

// Event listener per il tasto Invio nell'input
document.getElementById('importInput').addEventListener('keypress', function(event) {
    if (event.key === 'Enter') {
        addImport();
    }
});

// Funzione per creare il grafico
function createChart() {
    const canvas = document.getElementById('monthlyChart');
    const ctx = canvas.getContext('2d');
    
    // Pulire il canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (historicalEntries.length === 0) {
        // Messaggio se non ci sono dati
        ctx.fillStyle = '#fff';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Nessun dato storico disponibile', canvas.width / 2, canvas.height / 2);
        return;
    }
    
    // Preparare i dati
    const values = historicalEntries.map(entry => parseFloat(entry.importo));
    const labels = historicalEntries.map(entry => entry.periodo.split('al ')[1].trim());
    
    const maxValue = Math.max(...values);
    const minValue = Math.min(...values);
    const range = maxValue - minValue || 1;
    
    // Configurazione del grafico
    const padding = 50;
    const chartWidth = canvas.width - (padding * 2);
    const chartHeight = canvas.height - (padding * 2);
    
    // Disegnare gli assi
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, canvas.height - padding);
    ctx.lineTo(canvas.width - padding, canvas.height - padding);
    ctx.stroke();
    
    // Disegnare il grafico a linee
    if (values.length > 1) {
        ctx.strokeStyle = '#4caf50';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        values.forEach((value, index) => {
            const x = padding + (index * chartWidth) / (values.length - 1);
            const y = canvas.height - padding - ((value - minValue) / range) * chartHeight;
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
    }
    
    // Disegnare i punti
    ctx.fillStyle = '#fff';
    values.forEach((value, index) => {
        const x = padding + (index * chartWidth) / Math.max(values.length - 1, 1);
        const y = canvas.height - padding - ((value - minValue) / range) * chartHeight;
        
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, 2 * Math.PI);
        ctx.fill();
        
        // Etichetta del valore
        ctx.fillStyle = '#fff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(formatImport(value), x, y - 10);
        ctx.fillStyle = '#4caf50';
    });
    
    // Etichette sull'asse X
    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    labels.forEach((label, index) => {
        const x = padding + (index * chartWidth) / Math.max(labels.length - 1, 1);
        ctx.fillText(label, x, canvas.height - 20);
    });
}

function createHighResChart() {
    // Creare un canvas temporaneo ad alta risoluzione
    const highResCanvas = document.createElement('canvas');
    const highResCtx = highResCanvas.getContext('2d');
    
    // Impostare le dimensioni ad alta risoluzione
    const width = 7680; // 1920 * 4
    const height = 4320; // 1080 * 4
    highResCanvas.width = width;
    highResCanvas.height = height;
    
    // Sfondo bianco
    highResCtx.fillStyle = '#ffffff';
    highResCtx.fillRect(0, 0, width, height);
    
    if (historicalEntries.length === 0) {
        // Messaggio se non ci sono dati
        highResCtx.fillStyle = '#666';
        highResCtx.font = 'bold 120px Arial';
        highResCtx.textAlign = 'center';
        highResCtx.fillText('Nessun dato storico disponibile', width / 2, height / 2);
        return highResCanvas;
    }
    
    // Preparare i dati
    const values = historicalEntries.map(entry => parseFloat(entry.importo));
    const labels = historicalEntries.map(entry => entry.periodo.split('al ')[1].trim());
    
    const maxValue = Math.max(...values);
    const minValue = Math.min(...values);
    const range = maxValue - minValue || 1;
    
    // Configurazione del grafico ad alta risoluzione
    const padding = 400;
    const chartWidth = width - (padding * 2);
    const chartHeight = height - (padding * 2);
    
    // Titolo
    highResCtx.fillStyle = '#333';
    highResCtx.font = 'bold 180px Arial';
    highResCtx.textAlign = 'center';
    highResCtx.fillText('Storico Mensile Trading', width / 2, 250);
    
    // Disegnare gli assi
    highResCtx.strokeStyle = '#333';
    highResCtx.lineWidth = 8;
    highResCtx.beginPath();
    highResCtx.moveTo(padding, padding);
    highResCtx.lineTo(padding, height - padding);
    highResCtx.lineTo(width - padding, height - padding);
    highResCtx.stroke();
    
    // Griglia
    highResCtx.strokeStyle = '#e0e0e0';
    highResCtx.lineWidth = 2;
    for (let i = 1; i < 10; i++) {
        const y = padding + (i * chartHeight) / 10;
        highResCtx.beginPath();
        highResCtx.moveTo(padding, y);
        highResCtx.lineTo(width - padding, y);
        highResCtx.stroke();
    }
    
    // Disegnare il grafico a linee
    if (values.length > 1) {
        highResCtx.strokeStyle = '#4caf50';
        highResCtx.lineWidth = 12;
        highResCtx.beginPath();
        
        values.forEach((value, index) => {
            const x = padding + (index * chartWidth) / (values.length - 1);
            const y = height - padding - ((value - minValue) / range) * chartHeight;
            
            if (index === 0) {
                highResCtx.moveTo(x, y);
            } else {
                highResCtx.lineTo(x, y);
            }
        });
        highResCtx.stroke();
    }
    
    // Disegnare i punti
    highResCtx.fillStyle = '#2e7d32';
    values.forEach((value, index) => {
        const x = padding + (index * chartWidth) / Math.max(values.length - 1, 1);
        const y = height - padding - ((value - minValue) / range) * chartHeight;
        
        highResCtx.beginPath();
        highResCtx.arc(x, y, 20, 0, 2 * Math.PI);
        highResCtx.fill();
        
        // Bordo bianco per i punti
        highResCtx.strokeStyle = '#fff';
        highResCtx.lineWidth = 6;
        highResCtx.stroke();
        
        // Etichetta del valore
        highResCtx.fillStyle = '#333';
        highResCtx.font = 'bold 60px Arial';
        highResCtx.textAlign = 'center';
        highResCtx.fillText(formatImport(value), x, y - 60);
    });
    
    // Etichette sull'asse X
    highResCtx.fillStyle = '#333';
    highResCtx.font = 'bold 50px Arial';
    highResCtx.textAlign = 'center';
    labels.forEach((label, index) => {
        const x = padding + (index * chartWidth) / Math.max(labels.length - 1, 1);
        highResCtx.fillText(label, x, height - 150);
    });
    
    // Etichette sull'asse Y
    highResCtx.textAlign = 'right';
    for (let i = 0; i <= 10; i++) {
        const value = minValue + (range * i) / 10;
        const y = height - padding - (i * chartHeight) / 10;
        highResCtx.fillText(formatImport(value), padding - 50, y + 20);
    }
    
    return highResCanvas;
}




// Funzione per scaricare il grafico
function downloadChart() {
    const highResCanvas = createHighResChart();
    const link = document.createElement('a');
    link.download = `grafico_storico_HR_${getCurrentDate().replace(/\./g, '-')}.png`;
    link.href = highResCanvas.toDataURL('image/png');
    link.click();
    showMessage('Grafico ad alta risoluzione scaricato con successo!', 'success');
}


// Funzione per scaricare la tabella storico in CSV
function downloadHistoricalTable() {
    if (historicalEntries.length === 0) {
        showMessage('Non ci sono dati storici da scaricare!', 'error');
        return;
    }
    const htmlContent = generateEditableTableHTML();
    const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `storico_mensile_editabile_${getCurrentDate().replace(/\./g, '-')}.html`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    showMessage('Tabella HTML editabile scaricata con successo!', 'success');
}

// Scarica sia la tabella Importi Mese Corrente sia la tabella Storico Mensile in un unico file HTML
function downloadCombinedTablesHTML() {
    if (currentMonthEntries.length === 0 && historicalEntries.length === 0) {
        showMessage('Non ci sono dati da scaricare!', 'error');
        return;
    }

    // Tabella Importi Mese Corrente
    let currentMonthTableHTML = `
        <h3>Importi Mese Corrente</h3>
        <div style="overflow-x: auto;">
            <table border="1" cellpadding="6" cellspacing="0" style="border-collapse: collapse; width: 100%;">
                <thead>
                    <tr>
                        <th>Data</th>
                        <th>Importo (‚Ç¨)</th>
                    </tr>
                </thead>
                <tbody>
    `;
    currentMonthEntries.forEach(entry => {
        currentMonthTableHTML += `
            <tr>
                <td>${entry.data}</td>
                <td>${formatImport(entry.importo)}</td>
            </tr>
        `;
    });
    currentMonthTableHTML += `
                </tbody>
            </table>
        </div>
    `;

    // Tabella Storico Mensile
    let historicalTableHTML = `
        <h3>Storico Mensile</h3>
        <div style="overflow-x: auto;">
            <table border="1" cellpadding="6" cellspacing="0" style="border-collapse: collapse; width: 100%;">
                <thead>
                    <tr>
                        <th>Periodo</th>
                        <th>Importo (‚Ç¨)</th>
                    </tr>
                </thead>
                <tbody>
    `;
    historicalEntries.forEach(entry => {
        historicalTableHTML += `
            <tr>
                <td>${entry.periodo}</td>
                <td>${formatImport(entry.importo)}</td>
            </tr>
        `;
    });
    // Calcola il totale storico
    const total = historicalEntries.reduce((sum, entry) => sum + parseFloat(entry.importo), 0);
    historicalTableHTML += `
            <tr style="font-weight:bold; background:#eef;">
                <td>TOTALE</td>
                <td>${formatImport(total)}</td>
            </tr>
        </tbody>
    </table>
    </div>
    `;

    // Unisci le due tabelle in un unico HTML
    const combinedHTML = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Storico e Importi Mese Corrente</title>
</head>
<body>
    ${currentMonthTableHTML}
    <br><br>
    ${historicalTableHTML}
</body>
</html>
    `;

    // Download
    const blob = new Blob([combinedHTML], { type: 'text/html;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `importi_e_storico_${getCurrentDate().replace(/\./g, '-')}.html`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);

    showMessage('Tabelle HTML scaricate con successo!', 'success');
}



// Event listener per cancellare l'ultimo dato
document.getElementById('deleteLastButton').addEventListener('click', deleteLastEntry);

// Event listener per chiudere il mese
document.getElementById('closeMonthButton').addEventListener('click', closeMonth);

// Event listener per scarica dati
document.getElementById('scaricaDatiBtn').addEventListener('click', scaricaDati);

// Event listener per carica dati
document.getElementById('caricaDatiBtn').addEventListener('click', caricaDati);

// Stilizzazione del file input per migliorare l'esperienza utente
document.getElementById('fileInput').addEventListener('change', function() {
    const fileName = this.files[0]?.name;
    if (fileName) {
        this.nextElementSibling.textContent = fileName;
    } else {
        this.nextElementSibling.textContent = 'Seleziona File';
    }
});

// Carichiamo i dati dal localStorage all'avvio
loadFromLocalStorage();

// Inizializzazione dell'applicazione
updateAll();

// Event listener per scaricare il grafico
document.getElementById('downloadChartBtn').addEventListener('click', downloadChart);

// Event listener per scaricare la tabella storico
document.getElementById('downloadTableBtn').addEventListener('click', downloadCombinedTablesHTML);




// Aggiornare la funzione updateAll esistente per includere il grafico
function updateAll() {
    updateCurrentMonthTable();
    updateHistoricalTable();
    updateDashboard();
    createChart(); // Aggiungi questa riga
}


    </script>

<script type="module">
  import { initFirebase, caricaDatiPagina, salvaDatiPagina } from './firebase-utils.js';

  const nomePagina = "operativita"; // cambia per ogni pagina!

  let datiCorrenti = null;

  // Avvio
  initFirebase().then(async () => {
    datiCorrenti = await caricaDatiPagina(nomePagina);
    if (datiCorrenti) {
      console.log("‚úÖ Dati caricati:", datiCorrenti);
      // carica nella UI
    } else {
      console.log("‚ÑπÔ∏è Nessun dato presente.");
    }
  });

  // Quando vuoi salvare (es. su pulsante o evento)
  function salva() {
    // datiCorrenti = aggiorna con i nuovi dati
    salvaDatiPagina(nomePagina, datiCorrenti);
  }
</script>

</body>
</html>